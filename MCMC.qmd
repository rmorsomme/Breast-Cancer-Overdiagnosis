---
title: "MCMC"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r}
#setup parallel backend to use many processors
#cl <- makeCluster(detectCores()-2) #not to overload your computer
#registerDoParallel(cl)
  
library(tidyverse)
library(tictoc)
#library(furrr)
#library(foreach)
#library(doParallel)
```

## MCMC

```{r}
set.seed(1)
n <- nrow(d_process) # number of individuals
m <- 1e3             # number of MCMC iterations

#plan(multisession, workers = 7) # set the number of CPU cores to use when parallel processing

out <- MCMC(m=m) 
#profvis::profvis({out <- MCMC(m=m) }, interval =0.001)
save(list="out", file=paste0("MCMC-n", n, "-m", m, ".RDATA"))
```

## Output -- theta

```{r}
load(paste0("MCMC-n", n, "-m", m, ".RDATA"))
THETA <- out$THETA

RATE_H <- THETA$RATE_H
RATE_P <- THETA$RATE_P
PSY    <- THETA$PSY
BETA   <- THETA$BETA

plot(RATE_H, type = "l")
plot(RATE_P, type = "l")
plot(PSY   , type = "l")
plot(BETA  , type = "l")

# Output
x <- seq(1e-5, max(RATE_H, RATE_P, BETA, PSY), 0.0001)
hist(RATE_H, freq=F, breaks=20); abline(v=theta$rate_H, col = "red"); lines(x, dgamma(x, prior$shape_H, prior$rate_H))
hist(RATE_P, freq=F, breaks=20); abline(v=theta$rate_P, col = "red"); lines(x, dgamma(x, prior$shape_P, prior$rate_P))
hist(PSY   , freq=F, breaks=20); abline(v=theta$psy   , col = "red"); lines(x, dbeta(x, prior$a_psy, prior$b_psy))
hist(BETA  , freq=F, breaks=20); abline(v=theta$beta  , col = "red"); lines(x, dbeta(x, prior$a_beta, prior$b_beta))

acf(RATE_H)
acf(RATE_P)
acf(PSY)
acf(BETA)

coda::effectiveSize(RATE_H)
coda::effectiveSize(RATE_P)
coda::effectiveSize(PSY)
coda::effectiveSize(BETA)

runtime <- out$runtime
run_time <- runtime$toc - runtime$tic
coda::effectiveSize(RATE_H)/run_time
coda::effectiveSize(RATE_P)/run_time
coda::effectiveSize(PSY)/run_time
coda::effectiveSize(BETA)/run_time


THETA <- tibble(log(RATE_H), log(RATE_P), BETA, PSY)
round(cor(THETA), 2)
plot(THETA)
```

## Output -- latent data

```{r}
TAU_HP     <- out$TAU_HP
TAU_HP_inf <- is.infinite(TAU_HP) 

ids <- which(d_obs_censor$censor_type=="clinical")
i <- ids[21]
filter(d_obs_screen, person_id == i); d_process[i,]; d_obs_censor[i,]
plot(TAU_HP_inf[,i], type="l")
plot(TAU_HP[,i], type="l")
hist(TAU_HP[,i], breaks = 200, xlim=c(max(40, max(TAU_HP[,i]) - 15), max(TAU_HP[,i]))) # propose from truncated Weibull/triangular distribution instead of uniform?
acf(TAU_HP[,i])

rate_accept <- numeric(length(ids)) 
for(i in 1:length(ids)){ # acceptance rate
  rate_accept[i] <- mean(TAU_HP[2:m-1,ids[i]] != TAU_HP[2:m,ids[i]])
}
boxplot(rate_accept); summary(rate_accept); which.min(rate_accept); which.max(rate_accept)
plot(d_obs_censor$censor_time[ids], rate_accept)

ids <- which(d_obs_censor$censor_type=="screen")
i <- ids[1]
filter(d_obs_screen, person_id == i); d_process[i,]; d_obs_censor[i,]
plot(TAU_HP_inf[,i], type="l")
plot(TAU_HP[,i], type="l")
hist(TAU_HP[,i], breaks=50)
acf(TAU_HP[,i])

rate_accept <- numeric(length(ids)) 
for(i in 1:length(ids)){ # acceptance rate
  rate_accept[i] <- mean(TAU_HP[2:m-1,ids[i]] != TAU_HP[2:m,ids[i]])
}
boxplot(rate_accept); summary(rate_accept); which.min(rate_accept); which.max(rate_accept)
boxplot(rate_accept ~ d_obs_censor$censor_time[ids])

ids <- which(d_obs_censor$censor_type=="censored")
i <- ids[1]
d_process[i,]; filter(d_obs_screen, person_id == i); d_obs_censor[i,]
plot(TAU_HP_inf[,i], type="l")
acf(as.numeric(TAU_HP_inf[,i]))
plot(TAU_HP[!TAU_HP_inf[,i],i], type="l")

prop_inf <- colMeans(TAU_HP_inf[,ids])
boxplot(prop_inf) # is this plausible?
summary(prop_inf)
which.min(prop_inf); which.max(prop_inf)
plot(d_obs_censor$censor_time[ids], prop_inf, xlab = "Censoring age (c)", ylab = "Probability of (c<tau)")
plot(d_obs_censor$censor_time[ids], prop_inf, xlab = "Censoring age (c)", ylab = "Probability of (c<tau)", xlim=c(40,70))
```
